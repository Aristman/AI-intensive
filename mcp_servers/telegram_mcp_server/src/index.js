import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  ListToolsRequestSchema,
  CallToolRequestSchema,
  InitializeRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { config } from './config.js';
import { setupTelegramClient } from './utils.js';
import { list as listResources, read as readResource } from './handlers/resources.js';
import { createToolsHandler } from './handlers/tools.js';

// Reserve stdout exclusively for MCP protocol frames. Redirect app logs to stderr.
// This avoids any accidental writes to stdout by dependencies (e.g., gramJS) corrupting the MCP stream.
try {
  const toStderr = (method) => (
    /** @param {...any} args */
    (...args) => {
      // eslint-disable-next-line no-console
      console.error(...args);
    }
  );
  // eslint-disable-next-line no-console
  console.log = toStderr('log');
  // eslint-disable-next-line no-console
  console.info = toStderr('info');
  // eslint-disable-next-line no-console
  console.warn = toStderr('warn');
} catch {}

// DEBUG: instrument process.stdout.write to observe MCP frames generated by the SDK.
// We only log to stderr and then forward the original write to stdout unchanged.
try {
  const _origStdoutWrite = process.stdout.write.bind(process.stdout);
  process.stdout.write = (chunk, encoding, cb) => {
    try {
      const isString = typeof chunk === 'string';
      const len = isString ? Buffer.byteLength(chunk, encoding || 'utf8') : (chunk?.length || 0);
      // eslint-disable-next-line no-console
      console.error(`[MCP-DEBUG] stdout.write ${len} bytes`);
      if (len > 0) {
        const buf = isString ? Buffer.from(chunk, encoding || 'utf8') : Buffer.from(chunk);
        const preview = buf.subarray(0, Math.min(200, buf.length)).toString('utf8')
          .replace(/\r/g, '\\r').replace(/\n/g, '\\n');
        // eslint-disable-next-line no-console
        console.error(`[MCP-DEBUG] stdout preview: ${preview}`);
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error('[MCP-DEBUG] stdout.write logging error:', e?.message || e);
    }
    return _origStdoutWrite(chunk, encoding, cb);
  };
} catch {}

// NOTE: Do NOT attach listeners to process.stdin here.
// StdioServerTransport must have exclusive read access to stdin to parse MCP frames.

/**
 * Главная функция для запуска MCP сервера Telegram.
 */
async function main() {
  try {
    // Создаем экземпляр сервера MCP и сразу подключаем транспорт STDIO,
    // чтобы немедленно ответить на 'initialize' от клиента.
    const server = new Server({ name: config.name, version: config.version });
    const transport = new StdioServerTransport();
    // Connect stdio transport; after this the SDK should handle initialize automatically.
    await server.connect(transport);
    console.error('MCP transport connected (stdio).');

    // Регистрируем обработчики сразу, даже если Telegram клиент ещё не готов
    let tools = null;
    let tgClient = null;

    server.setRequestHandler(ListResourcesRequestSchema, async () => {
      const resources = await listResources();
      console.error(`[MCP-DEBUG] list/resources -> ${resources?.length ?? 0} items`);
      return { resources };
    });

    server.setRequestHandler(ReadResourceRequestSchema, async ({ params }) => {
      const result = await readResource({ uri: params.uri });
      if (Array.isArray(result?.contents)) {
        console.error(`[MCP-DEBUG] read/resource(${params.uri}) -> contents array size=${result.contents.length}`);
        return { contents: result.contents };
      }
      console.error(`[MCP-DEBUG] read/resource(${params.uri}) -> wrapping single result`);
      return {
        contents: [
          {
            uri: params.uri,
            mimeType: 'application/json',
            text: JSON.stringify(result ?? {}),
          },
        ],
      };
    });

    server.setRequestHandler(ListToolsRequestSchema, async () => {
      if (!tools) {
        // Пока клиент не готов — возвращаем минимальный список или пусто
        console.error('[MCP-DEBUG] tools/list -> tools not ready, returning []');
        return { tools: [] };
      }
      const list = await tools.list();
      console.error(`[MCP-DEBUG] tools/list -> ${Array.isArray(list) ? list.length : 0} tools`);
      return { tools: list };
    });

    server.setRequestHandler(CallToolRequestSchema, async ({ params }) => {
      if (!tools) {
        const text = JSON.stringify({ error: 'Tools not ready' });
        console.error(`[MCP-DEBUG] tools/call(${params?.name}) -> tools not ready`);
        return { content: [{ type: 'text', text }] };
      }
      const toolName = params.name;
      const args = params.arguments ?? {};
      console.error(`[MCP-DEBUG] tools/call name=${toolName} args=${JSON.stringify(args).slice(0,200)}`);
      const raw = await tools.call({ name: toolName, arguments: args });
      const text = typeof raw === 'string' ? raw : JSON.stringify(raw);
      console.error(`[MCP-DEBUG] tools/call result bytes=${Buffer.byteLength(text, 'utf8')}`);
      return { content: [{ type: 'text', text }] };
    });

    // Инициализируем Telegram клиента в фоне и активируем инструменты, когда он будет готов
    (async () => {
      try {
        tgClient = await setupTelegramClient(config.telegram);
        tools = createToolsHandler(tgClient);
        console.error('Telegram client ready, tools registered.');
      } catch (e) {
        console.error('Failed to initialize Telegram client in background:', e?.message || e);
      }
    })();

    console.error('MCP server started successfully.');

    // Обработка graceful shutdown
    process.on('SIGINT', async () => {
      console.error('Shutting down...');
      try {
        if (tgClient) await tgClient.disconnect();
      } catch {}
      process.exit(0);
    });

  } catch (error) {
    console.error('Failed to start server:', error.message || error);
    process.exit(1);
  }
}

// Запускаем сервер
main();
