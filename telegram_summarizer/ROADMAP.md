# telegram_summarizer — ROADMAP

Дата: 2025-08-28
Статус: В работе; централизованная MCP‑интеграция в агенте и тесты — готово
Ответственный: TBD

## Цели
- Создать отдельное Flutter‑приложение `telegram_summarizer` в корне репозитория (не связано с sample_app кодом напрямую, но следует тем же практикам).
- Интегрировать LLM YandexGPT (IAM + x-folder-id) для суммаризации.
- Подключить сторонний MCP сервер (WebSocket JSON‑RPC), конфигурируемый в Настройках.
- Отображать человека‑читаемые сводки из `structuredContent` (карточки с кнопкой «Копировать»).
- Сохранять контекст чата и настройки в SharedPreferences. Кнопка «Очистка контекста» в AppBar.

## Критерии MVP (готовности)
- LLM (YandexGPT) работает: пользователь отправляет запрос → получаем ответ LLM.
- MCP подключается (настраиваемый ws:// URL), базовые вызовы через JSON‑RPC (`capabilities`, `summarize`) работают и используются агентом. В дальнейшем — `tg.resolve_chat`, `tg.fetch_history`.
- По запросу пользователю отображается сводка: parsed `structuredContent` → карточки со сводной информацией, доступна кнопка «Копировать».
- UI по спецификации: AppBar (название, модель, «Очистка», «Настройки»), лента сообщений (пользователь — голубой фон; LLM текст — светло‑зелёный; сводки — карточки).
- Контекст чата и настройки персистятся (SharedPreferences). Очистка контекста работает.
- Индикация состояния MCP в AppBar (точка статуса + кнопка «Переподключить»).

## Вне зоны (позже)
- Расширенные шаблоны рендера для tg.* инструментов (этап 2).
- Глубокий оркестратор с многошаговыми вызовами MCP и проверкой схем — после MVP.
- Авторизация MCP (токен/handshake) — появится спецификация стороннего сервера.

---

## Сделано (2025-08-29)
- Обновлён iOS bundle identifier в `ios/Runner.xcodeproj/project.pbxproj` для Runner (Debug/Release/Profile) и RunnerTests: `ru.marslab.telegram.summarizer` и `ru.marslab.telegram.summarizer.RunnerTests`.
- Подтверждён `CFBundleDisplayName = "Telegram Summarizer"` в `ios/Runner/Info.plist`.
- Исправлен pending Timer в `lib/ui/chat_screen.dart::_send()` — заменён `Future.delayed` на `WidgetsBinding.instance.addPostFrameCallback` для стабильных виджет‑тестов.
- Виджет‑тесты проходят: `flutter test` зелёный.
- Добавлена индикация статуса MCP в `chat_screen.dart` (зелёная/красная точка) и кнопка «Переподключить» (вызывает `ChatState.reconnectMcp()`).
- Интеграция MCP вынесена в `SimpleAgent`: после подключения MCP агент подтягивает `capabilities` и добавляет их в системный промпт LLM; `askRich()` возвращает `structuredContent` (успешный `summarize`). `ChatState` не вызывает MCP напрямую.

- `SummaryCard`: отображает строковое поле `summary` отдельно над JSON; добавлены виджет‑тесты рендера и копирования. Добавлены виджет‑тесты индикатора статуса MCP и кнопки переподключения.

- Тултип индикатора MCP при подключении показывает краткий список доступных инструментов (capabilities/tools).
- Добавлены e2e‑тесты для capabilities:
  - `test/chat_screen_e2e_capabilities_test.dart` — проверяет добавление capabilities в системное сообщение и появление `SummaryCard`.
  - `test/chat_screen_e2e_caps_influence_test.dart` — демонстрирует влияние capabilities: ответ LLM отличается при наличии/отсутствии capabilities; тултип показывает список инструментов.

## Архитектура (высокоуровнево)
- Flutter (как в `sample_app/`): Provider/ChangeNotifier для настроек и состояния чата; виджет‑тесты.
- Модули:
  - `core/` — модели, утилиты, константы.
  - `data/llm/` — YandexGPT usecase (IAM), резолвер модели.
  - `data/mcp/` — WebSocket JSON‑RPC клиент (initialize, tools/list, tools/call), абстракция результатов (content[], structuredContent, resources).
  - `domain/` — интеракторы: отправка запроса, цикл «LLM ↔ MCP ↔ рендер» (упрощённый на MVP).
  - `ui/` — экраны: ChatScreen, SettingsScreen; виджеты: MessageBubble, SummaryCard.
  - `storage/` — SharedPreferences: история, настройки (модель, MCP URL, пр.).

- Поток данных (MVP):
  1) Пользователь вводит запрос → `ChatController.send()`
  2) При необходимости дергаем MCP (по кнопке/эвристике «есть tg.») → `McpClient.tools.call()`
  3) Собираем `structuredContent` → «SummaryCardRenderer» → карточки
  4) LLM (YandexGPT) формирует итоговую текстовую выжимку (и/или инструкции к MCP) → сообщение LLM
  5) Сохраняем историю в SharedPreferences.

---

## Этапы и задачи

### Этап 0. Подготовка структуры проекта
- [x] Создать каталог `telegram_summarizer/` в корне.
- [x] Инициализировать Flutter‑приложение (кроссплатформенно, как в `sample_app`).
- [x] Добавить файлы:
  - [x] `README.md`
  - [x] `.gitignore`
  - [x] `assets/.env.example` (плейсхолдеры IAM), `.env` добавлен в .gitignore
  - [x] `pubspec.yaml` (dependencies заданы)
- [x] Настроить lints/форматирование/CI:
  - [x] Lints (`analysis_options.yaml`)
  - [x] Форматирование (стандартное `flutter format`)
  - [x] Базовые CI шаги (минимум: `flutter analyze`, `flutter test`) — GitHub Actions: `.github/workflows/flutter-ci.yml`

### Этап 1. Базовый UI (каркас)
- [x] Экран `ChatScreen`: AppBar (название «Telegram Summarizer», текущее имя модели; кнопки «Очистка», «Настройки»). 
- [x] Лента сообщений: 
      - Сообщения пользователя — голубой фон.
      - Сообщения LLM текст — светло‑зелёный фон.
      - Сообщения со сводкой — контейнер‑карточка, «Копировать».
- [x] Поле ввода + кнопка «Отправить».
- [x] Навигация к `SettingsScreen`.

### Этап 2. Хранилище и настройки (SharedPreferences)
    - [x] Модель настроек: выбор модели YandexGPT, поля IAM + `x-folder-id`, MCP URL.
    - [x] Провайдер настроек + персист в SharedPreferences.
    - [x] История чата: модель сообщений, сериализация и персист (ограничение по длине истории, ротация).
    - [x] Кнопка «Очистка контекста»: сбрасывает историю (локальный кэш MCP — не используется на текущем этапе).

### Этап 3. LLM: YandexGPT (IAM)
- [x] Импорт минимального usecase по образцу `sample_app` через API‑Key (поддержка также IAM + `x-folder-id`).
- [x] Резолвер модели (настройки → конечная конфигурация запросов).
- [x] Ошибки/ретраи, тайм‑ауты, лимиты токенов (timeouts/retries добавлены в `YandexGptUseCase`).
- [x] Юнит‑тесты: успешный ответ, ошибка, обработка тайм‑аута и ретраев.
- [x] Простой агент с сохранением контекста и сжатием (SimpleAgent + тесты).

### Этап 4. MCP клиент (WebSocket JSON‑RPC)
- [x] Клиент: connect/close, базовый `call`, `summarize` (JSON‑RPC по WebSocket).
- [ ] Расширение: `initialize`, `tools/list`, `tools/call` (после MVP).
- [x] Конфиги через Settings: MCP URL, автоподключение при старте UI.
- [x] Интеграция в агент: `refreshMcpCapabilities()` и системный промпт LLM.
- [ ] Модель ответа: поддержка `content[]`, `structuredContent`, `resources` (частично: `structuredContent`).
- [ ] Обработка расширенных ошибок (`FLOOD_WAIT`, `CHANNEL_PRIVATE`, и пр.).
- [x] Фейки/моки для интеграционных тестов (capabilities, summarize, ошибки summarize).

### Этап 5. Рендер сводок (structuredContent)
- [ ] JSON Schema‑валидируемый парсер structuredContent.
- [x] Универсальный рендер карточек (без специализированных шаблонов на MVP).
- [x] Кнопка «Копировать» в карточке (копирует читаемую выжимку/JSON по настройке).
- [x] Виджет‑тесты: корректный рендер, копирование.

### Этап 6. Оркестрация запроса (MVP‑логика)
- [ ] Простая стратегия: 
      - Если запрос содержит маркеры Telegram/канала/периода → выполнить `tg.resolve_chat` → `tg.fetch_history` (1–2 страницы, ограничение).
      - Сформировать `structuredContent` агрегат для рендера карточек.
      - Отправить в LLM user‑запрос + краткий контекст из MCP → получить текстовую выжимку.
- [x] Отображение: карточки сводки + ответ LLM (через `askRich()` и рендер `structuredContent`).
- [x] Индикация состояний: подключение MCP (желтый/зеленый/красный), ошибки MCP показываются отдельно, не как `structuredContent`.

### Этап 7. Тестирование
- [x] Юнит‑тесты: агент + MCP (`askRich`, capabilities → системный промпт; успешный/ошибочный summarize).
- [ ] Юнит‑тесты: парсер/рендер structuredContent; LLM usecase; MCP клиент (расширенные ошибки).
- [ ] Виджет‑тесты: Chat UI, Settings, очистка контекста, копирование.
- [ ] Интеграционные: сценарий MVP с мок‑MCP (resolve → fetch → summary → LLM).
- [x] Все тесты проходят локально (как в репо — правило качества).

### Этап 8. Документация
- [ ] `telegram_summarizer/README.md`: быстрый старт, настройки IAM/Yandex, MCP URL, сценарии, ограничения.
- [ ] Описание форматов MCP (content[], structuredContent, resources) и кодов ошибок.
- [ ] Скриншоты UI (по возможности).

### Этап 9. Релиз MVP
- [ ] Smoke‑проверка Win/macOS/Linux/Web (минимум: Win + Web).
- [ ] Проверка ручного сценария: ввод запроса → MCP сводка → ответ LLM.
- [ ] Тэг релиза в репозитории (internal).

---

## План этапа 2 (после MVP): шаблоны для tg.*
- [ ] Добавить специальные рендеры для `tg.resolve_chat` и `tg.fetch_history` (даты, ссылки, счётчики просмотров/пересылок, пагинация).
- [ ] Улучшить оркестрацию: многошаговые запросы, агрегации, дедупликация, поддержка resources (NDJSON).
- [ ] Настраиваемые лимиты (page_size, период времени, фильтры).

## Риски и допущения
- MCP сторонний и в разработке: специфика авторизации/схем может измениться. На MVP — без auth, гибкие модели данных.
- IAM‑учётки/квоты YandexGPT: требуется корректная конфигурация окружения.
- Пагинация и лимиты MCP: аккуратно выбирать дефолты (≤100 сообщений/страница, курсоры base64) и не блокировать UI.

## Готовые артефакты к конечной точке MVP
- Исходники приложения в `telegram_summarizer/`.
- Полный набор тестов (юнит/виджет/интеграция) — все проходят.
- README с инструкциями.
- Демонстрационный скрин/видео сценария MVP (опционально).
